# 34-35-36-37

# ПАРАГРАФ 34
Вот ответы на ваши вопросы:

### 1. Зачем понадобилось уточнять понятие «алгоритм»?

Уточнение понятия «алгоритм» необходимо для ясности и точности в области информатики и математики. Алгоритмы являются основой программирования и вычислений, и четкое определение помогает в формализации, анализе и разработке алгоритмических решений. Это также позволяет избежать неоднозначностей и обеспечить лучшее понимание методов решения задач.

### 2. Какие задачи рассматриваются в теории алгоритмов?

В теории алгоритмов рассматриваются задачи, связанные с:
- Разработкой и анализом алгоритмов (например, сложность, эффективность).

- Классификацией задач (например, вычислимые и невычислимые задачи).

- Исследованием различных моделей вычислений (например, машины Тьюринга, комбинаторные алгоритмы).

- Оптимизацией алгоритмов и решением задач, связанных с их применением.

### 3. Почему можно ограничиться алгоритмами обработки символьных строк? Можно ли рассматривать только алгоритмы для преобразования двоичных кодов?

Можно ограничиться алгоритмами обработки символьных строк, поскольку любые данные, включая двоичные коды, могут быть представлены как строки символов (например, 0 и 1). Это позволяет абстрагироваться от представления данных и сосредоточиться на логике обработки. Однако также возможно рассматривать специальные алгоритмы для обработки двоичных кодов, так как они могут быть более эффективными для конкретных задач, связанных с низкоуровневыми вычислениями.

### 4. Как вы понимаете утверждение «Алгоритм задаёт некоторую функцию»?

Это утверждение подразумевает, что любой алгоритм можно рассматривать как функцию, преобразующую входные данные в выходные данные. Таким образом, алгоритмы выполняют действие, которое определяет, как следует обрабатывать данные, чтобы получить определённый результат.

### 5. Как связаны понятия «алгоритм» и «исполнитель»?

Алгоритм — это набор инструкций, который определяет, как выполнять конкретные задачи, а исполнитель — это устройство или программа, которая фактически выполняет алгоритм. Исполнитель может быть как человеком, так и вычислительной машиной. Связь между ними заключается в том, что исполнитель реализует алгоритм на практике.

### 6. Что такое программа?

Программа — это формализованный алгоритм, записанный в виде инструкций, которые могут быть выполнены компьютером. Программа содержит код, который описывает, как выполнять алгоритм на основе определённого языка программирования.

### 7. В каком случае говорят, что два алгоритма эквивалентны?

Два алгоритма считаются эквивалентными, если они решают одну и ту же задачу и для одного и того же набора входных данных выдают одинаковые выходные результаты, несмотря на различия в их реализации.

### 8. Что такое универсальный исполнитель?

Универсальный исполнитель — это теоретическая модель (например, машина Тьюринга), способная выполнять любой алгоритм без специальной настройки. Он может обрабатывать любую задачу, которая может быть формализована в виде алгоритма, таким образом, позволяя выполнять множество различных вычислений.

### 9. Сравните интуитивное и строгое понятия алгоритма.

Интуитивное понятие алгоритма часто связано с представлением о последовательности шагов, необходимых для решения задачи. Это понятие может быть менее формализованным и зависит от контекста. Строгое понятие алгоритма основывается на формальных определениях, включающих четко определенные входы, выходы, последовательность шагов, завершенность и разрешимость. Строгое определение позволяет провести более глубокий анализ и обоснование свойств алгоритмов.

### 10. Опишите устройство и систему программирования машины Тьюринга.

Машина Тьюринга состоит из бесконечной ленты, разделенной на ячейки, выполненной в виде tape, считывающей и записывающей головки, и таблицы переходов (или функции перехода), которая управляет поведением машины. Система программирования позволяет задавать правила того, как машина должна реагировать на символы, находящиеся на ленте, изменять их и перемещаться по ленте. Каждый переход зависит от текущего состояния машины и символа под головкой.

### 11. Что такое состояние машины Тьюринга?

Состояние машины Тьюринга — это одно из возможных состояний, в которых может находиться машина в процессе выполнения алгоритма. Оно определяет, как машина будет реагировать на текущий символ на ленте и какие действия следует предпринять (что записать и куда переместить головку).

### 12. Сопоставьте устройство машины Тьюринга с устройством компьютера.

- **Лента** (в машине Тьюринга) аналогична **памяти** компьютера, где хранятся данные и инструкции.

- **Головка** (считывающая и записывающая) соответствует **процессору**, который выполняет операции с данными.

- **Состояния** машины аналогичны **регистрам** и состояниям выполнения программ в компьютере, определяя, какая часть кода исполняется в данный момент.

### 13. В чем особенность состояний до и д, машины Тьюринга?

Состояния "до" и "д" в машине Тьюринга могут обозначать специальные точки в процессе обработки, такие как начальное и конечное состояния. Это позволят машине начать обработку или определять завершение процесса. Эти состояния часто играют ключевую роль в определении того, что машина должна делать в ответ на входные данные.

### 14. По какому принципу можно построить программу для машины Тьюринга, которая последовательно выполняет операции А и Б?

Программу для машины Тьюринга, выполняющую последовательные операции А и Б, следует строить так, чтобы после завершения первой операции (А) она переходила ко второй (Б), используя соответствующую таблицу переходов и состояния, что обеспечивает плавный переход между операциями.

### 15. Сформулируйте тезис Чёрча-Тьюринга.

Тезис Чёрча-Тьюринга утверждает, что любое вычислительное устройство, способное выполнять алгоритмические вычисления, можно смоделировать с помощью машины Тьюринга. Это заявление служит основой для теории вычислений, утверждая, что все вычислимые функции могут быть реализованы с помощью таких единиц, как алгоритмы или грамматики.

### 16. Сравните машины Тьюринга и Поста.

Машины Тьюринга и Поста обе являются формальными моделями вычислений, но имеют некоторые отличия:
- **Машина Тьюринга** включает в себя ленту, записывающую и считывающую головку и состояния, а **машина Поста** использует строки символов и набор правил для их трансформации.

- В машине Тьюринга возможна запись, перемещение и считывание, а в модели Поста действия определяются только на основе набора правил.

### 17. Зачем нумеруются строки в программе для машины Поста?

Строки в программе для машины Поста нумеруются для того, чтобы упростить обращение к различным частям программы и облегчить процесс чтения и исполнения. Нумерация позволяет обрабатывать команды и осуществлять переходы в программе эффективно, обеспечивая структурность.

### 18. Что такое нормальный алгоритм Маркова?

Нормальный алгоритм Маркова — это формальная система правил, используемая для описания последовательности вычислительных шагов, которые композируются и исполняются на основе определенного набора преобразований. Эти алгоритмы также служат примером вычислительных моделей, близких к формализму машины Тьюринга.

### 19. Зачем используют специальные символы в Нормальных Алгоритмах Маркова (НАМ)?

Специальные символы в Нормальных Алгоритмах Маркова используются для обозначения различных операций, состояний и разделителей данных, что помогает упорядочить и структурировать алгоритмы, облегчая их понимание и выполнение.

### 20. Что означает эквивалентность различных универсальных исполнителей?

Эквивалентность различных универсальных исполнителей означает, что разные модели вычислений (например, машины Тьюринга, комбинаторные машины, системы Поста) могут реализовать одни и те же вычисимые функции, несмотря на различия в архитектуре и механизмах работы. Это свидетельствует о том, что все эти модели имеют одинаковую вычислительную мощность. 

Если у вас есть более конкретные вопросы или необходима дополнительная информация, дайте знать!


# ПАРАГРАФ 35

Вот ответы на ваши вопросы:

### 1. Что такое вычислимая функция?

Вычислимая функция — это функция, которая может быть вычислена с помощью алгоритма на некотором вычислительном устройстве (например, на машине Тьюринга или компьютере). Формально, функция называется вычислимой, если существует алгоритм, который при заданном входном значении выводит соответствующее значение функции за конечное время.

### 2. Приведите пример невычислимой функции.

Примером невычислимой функции является функция, определяющая, останавливается ли произвольная программа на произвольном входе, известная как «проблема остановки». Если задать алгоритм, который принимает на вход описание программы и входные данные, он не сможет ответить, остановится эта программа или будет работать бесконечно, для всех возможных вводов.

### 3. Что такое алгоритмически неразрешимые задачи? Приведите известные вам примеры.

Алгоритмически неразрешимые задачи — это задачи, для которых не существует алгоритма, способного решить их для всех возможных входных данных за конечное время. Примеры таких задач включают:
- Проблема останова.

- Проблема предсказания, останавливается ли программа для всех возможных входов.

- Проблема эквивалентности двух произвольных программ — нельзя алгоритмически определить, эквивалентны ли они (выдают ли они одинаковые выходы для всех возможных входов).

### 4. Что такое проблема остановки? Каковы её следствия?

Проблема остановки (или проблема Тьюринга) формулируется следующим образом: для данного алгоритма (или программы) и входных данных невозможно создать алгоритм, который бы определял, остановится ли данный алгоритм для этих данных, или будет работать бесконечно. Следствия этой проблемы включают:
- Невозможность универсального тестирования программ на выход или поведение (например, на наличие бесконечных циклов).

- Ограничения в разработке и анализе программ и алгоритмов, возникающие из невозможности автоматической проверки некоторых свойств алгоритмов.

### 5. Что такое проблема эквивалентности?

Проблема эквивалентности заключается в определении, выдаёт ли две разные программы (или алгоритмы) одинаковые выходные данные для всех возможных входов. Эта проблема также является алгоритмически неразрешимой; невозможно создать универсальный алгоритм, который мог бы достоверно определить эквивалентность двух произвольных программ для всех возможных входных данных.

### 6. Как можно доказать алгоритмическую неразрешимость новой задачи?

Доказательство алгоритмической неразрешимости новой задачи обычно осуществляется методом редукции. Это значит, что достаточно показать, что если бы новая задача была разрешима, то можно было бы разрешить уже известную неразрешимую задачу:
- Выберите уже известную невычислимую задачу (например, проблему останова).

- Приведите её к новой задаче с помощью алгоритмической редукции, построив функцию или алгоритм, который решает известную задачу, если известная неразрешимая задача решена.

- Если удастся построить такое сведение, это означает, что новая задача тоже неразрешима.

Каждый из этих шагов помогает формально обосновать, что новая задача также имеет свойства неразрешимости.

# ПАРАГРАФ 36

Вот ответы на ваши вопросы о качественных характеристиках алгоритмов:

### 1. Какие критерии используются для оценки качества алгоритмов?

Критерии оценки качества алгоритмов включают:
- **Сложность алгоритма:** Оценивает, сколько ресурсов (по времени и по памяти) необходимо для выполнения алгоритма.

- **Производительность:** Обозначает, насколько быстро алгоритм выполняет свою задачу.

- **Эффективность:** Отражает соотношение между использованием ресурсов и достигнутыми результатами.

- **Корректность:** Гарантирует, что алгоритм производит правильные выходные данные для всех допустимых входов.

- **Устойчивость:** Оценка, как алгоритм справляется с изменениями в начальных условиях или входных данных.

- **Простота реализации:** Легкость кодирования и понимания алгоритма.

- **Устойчивость (или устойчивость к ошибкам):** Способность справляться с нештатными ситуациями или ошибками во входных данных.

### 2. Почему скорость работы алгоритма оценивается не временем выполнения, а количеством элементарных операций?

Скорость работы алгоритма оценивается количеством элементарных операций, поскольку время выполнения может варьироваться в зависимости от различных факторов, таких как конкретная машина, используемый компилятор, загруженность системы и т.д. Количество элементарных операций служит более абстрактной и согласованной метрикой, которая позволяет оценивать производительность алгоритма в более общем виде, без привязки к конкретным аппаратным или программным условиям. Это также упрощает сравнение различных алгоритмов независимо от их реализации.

### 3. Как учитывается размер данных при оценке скорости алгоритма?

Размер данных учитывается при оценке сложности алгоритма, обычно вот так:
- Определение параметра n как размер входных данных (например, количество элементов в массиве).

- Определение зависимости между количеством элементарных операций, необходимыми для выполнения алгоритма, и размером входных данных. Это может быть достигнуто через анализ различных случаев (лучший, средний и худший) для оценки максимального количества операций при увеличении n.

- Часто используются асимптотические нотации (например, O, Θ, Ω), чтобы описать, как алгоритмическая сложность изменяется в зависимости от размера входных данных.

### 4. Что означают записи О(1), O(n), O(n²) и O(2^n)?

- **O(1)**: Константная сложность. Время выполнения алгоритма не зависит от размера входных данных; оно остается фиксированным.

- **O(n)**: Линейная сложность. Время выполнения алгоритма пропорционально размеру входных данных. Если размер входа удваивается, то и время выполнения тоже удваивается.

- **O(n²)**: Квадратичная сложность. Время выполнения алгоритма пропорционально квадрату размера входных данных. Подходит для алгоритмов, работающих с парами элементов, например, в сортировке пузырьком.

- **O(2^n)**: Экспоненциальная сложность. Время выполнения алгоритма удваивается при каждом добавлении нового элемента. Обычно встречается в некоторых рекурсивных алгоритмах, например, при решении задач с перебором.

### 5. В каких случаях алгоритм, имеющий асимптотическую сложность O(n²), может работать быстрее, чем алгоритм с асимптотической сложностью O(log n)?

Алгоритм с сложностью O(n²) может работать быстрее, чем алгоритм с O(log n) в следующих случаях:
- **Маленький размер данных:** Если размер входных данных (n) маленький, то константные факторы и накладные расходы, связанные с логарифмическим алгоритмом, могут превышать время выполнения квадратичного алгоритма. В таких случаях O(n²) может быть фактически быстрее из-за меньшего количества операций.

- **При реализации конкретных алгоритмов:** Реализация алгоритмов может быть оптимизирована таким образом, что особенности конкретных входных данных делают O(n²) более эффективным, чем теоретически ожидаемая производительность O(log n).

- **Операции с малым количеством элементов:** Если алгоритм O(n²) выполняет всего несколько арифметических или простых операций при каждом вызове, он может оказаться более быстрым из-за низкой нагрузки от логарифмического алгоритма при его большом количестве вызовов. 

Эти случаи могут быть специфичными для конкретных условий задачи и вводимых данных.

# ПАРАГРАФ 37

Вот ответы на ваши вопросы о правильности программ и связанных с этим концепциях:

### 1. Зачем нужно доказывать правильность программ?

Доказывать правильность программ необходимо для обеспечения корректного выполнения алгоритма и достижения желаемого результата. Это позволяет:
- Минимизировать количество ошибок и сбоев при выполнении программы.

- Уверенность в том, что программа соответствует ее спецификациям и выполняет назначенные задачи.

- Обеспечить надежность и безопасность программных систем, особенно в критически важных приложениях (например, в авиации, медицине, финансовых системах).

### 2. Расскажите о двух подходах к проверке правильности программ.

Существует множество подходов к проверке правильности программ, но два наиболее распространенных:
- **Доказательство по индукции:** Этот метод включает формальную модель программы и доказательство, что она удовлетворяет определенным свойствам для всех входных данных с помощью индукции (например, для всех натуральных чисел).

- **Тестирование:** Этот подход заключается в запуске программы с различными входными данными в попытке проверить, соответствует ли она ожидаемому поведению. Однако это не всегда гарантирует полное отсутствие ошибок.

### 3. Почему с помощью тестирования сложно доказать правильность программы? В каких случаях это всё же можно сделать? Приведите примеры.

Тестирование сложно для доказательства правильности программы, потому что:
- Невозможно протестировать все возможные входные данные, особенно в случае больших и сложных программ.

- Тестирование не может выявить ошибки, которые возникают только при специфических или крайних условиях.

- Ошибки, связанные с логикой или состоянием программы, могут не проявиться во время тестирования. 

Однако в некоторых случаях можно провести доказательство правильности через тестирование, например, если:
- Программа имеет небольшой объем и количество входных данных.

- Проведен полный набор тестов, охватывающий все возможные сценарии.

- Используются методы, такие как тестирование на границах (boundary testing), чтобы охватить критические случаи.

### 4. Что изменится в доказательстве алгоритма Евклида, если t и p это произвольные натуральные числа (неравенство t и p может не выполняться)?

Если \( t \) и \( p \) являются произвольными натуральными числами, то алгоритм Евклида может потребовать дополнительно проверки, что оба числа не равны нулю, так как алгоритм не признает случаи, когда одно из чисел равно нулю. Также может потребоваться изменение формулировки инварианта, используемого в процессе доказательства, так как необходимо учесть все случаи, когда \( t \) меньше или больше \( p \) и их относительные положения. В итоге нужно формально доказать корректность алгоритма для всех возможных пар значений, что может усложнить процесс доказательства. 

### 5. Что такое инвариант цикла?

Инвариант цикла — это условие, которое верно в начале и в конце каждой итерации цикла. Он сохраняет свое истинное состояние, обеспечивая, что во время выполнения цикла сохраняется определенное свойство программы. Инварианты циклов помогают доказать корректность алгоритмов, описывая состояние переменных и их отношения на протяжении выполнения цикла.

### 6. Зачем нужно определять инвариант цикла?

Определение инварианта цикла позволяет:
- Доказать корректность выполнения цикла.

- Формально обосновать, что после завершения цикла выполнение программы соответствует спецификации.

- Обеспечить, что определенные свойства данных сохраняются в течение всего цикла.

### 7. Что такое спецификация? Почему желательно формулировать её в виде формальных утверждений, а не на естественном языке?

Спецификация — это формальное или неформальное описание требований к программе, включая её входные и выходные данные, поведение и возможные ошибки. Формулировать спецификации в виде формальных утверждений предпочтительнее, потому что:
- Формальные утверждения уменьшают неоднозначность и интерпретацию.

- Они обеспечивают строгость, позволяя применять математические методы для доказательства правильности.

- Формальные спецификации проще валидации и могут быть использованы для автоматизированных проверок.

### 8. Объясните запись {Q}S(R).

Запись {Q}S(R) обычно используется в контексте формальных спецификаций. Здесь:
- Q — это предусловие, которое должно быть выполнено перед выполнением программы или блока кода S.

- S — это программа или алгоритм, который выполняется.

- R — это постусловие, которое должно выполниться после завершения выполнения S.

Таким образом, данная запись говорит о том, что если предусловие Q выполнено, то выполнение S приведет к выполнению постусловия R.

### 9. Какая программа называется корректной?

Программа называется корректной, если она выполняет своё предназначение, то есть:
- Она соответствует своей спецификации (все заданные требования выполнены).

- Проверка завершает выполнение программы и приводит к ожидаемым результатам для всех допустимых входных данных.

### 10. Как вы думаете, можно ли назвать корректной программу, которая "зависает при неверных входных данных"? Обсудите этот вопрос в классе.

Корректность программы зависит от ее способности обрабатывать все возможные входные данные. Если программа «зависает» или не завершает выполнение при неверных входных данных, это может свидетельствовать о ее некорректности, поскольку она не выполняет требования спецификации. Важно обсудить, что корректность может быть при этом определена в контексте обработки ошибок и ожиданий: если ожидания пользователей включают обработку неправильных входных данных, то отсутствие такой обработки делает программу некорректной.

### 11. Что такое верификация программы?

Верификация программы — это процесс, с помощью которого устанавливается, что программа соответствует своей спецификации и выполняет нужные функции. Верификация включает в себя методы формального доказательства, тестирования и анализа, чтобы обеспечить, что программа работает так, как ожидалось, для всех возможных входных данных.

### 12. Как вы думаете, что сложнее — доказывать правильность готовой программы или сразу писать программу, доказывая правильность отдельных блоков? Почему? Обсудите этот вопрос в классе.

Этот вопрос может вызвать разные мнения, так как он зависит от контекста и методов разработки. Основные аргументы:
- Доказывать правильность готовой программы может быть сложнее, потому что требуется учитывать взаимодействие всех ее частей и возможность возникновения ошибок на стыке компонентов.

- С другой стороны, проектируя программу с самого начала, в процессе разработки можно поддерживать высокую степень структурированности и следить за тем, чтобы каждая отдельная часть была правильной, что может упростить будущую интеграцию.

Дискуссия может помочь выделить соображения и предпочтения в отношении разных методов разработки программного обеспечения.
